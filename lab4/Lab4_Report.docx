Laboratory Work 4 — SQL Queries, Functions and Operators
Student: Turlybekova Nurdana
University: Kazakh-British Technical University
Course: Database Systems

Objective
В этой лабораторной работе я тренировалась писать SQL-запросы с использованием разных операторов, функций и агрегатов.
Цель — научиться извлекать, фильтровать и анализировать данные с помощью SELECT, WHERE, CASE, GROUP BY, JOIN, подзапросов и оконных функций.


Part 1 — Basic SELECT Queries
В этой части я работала с простыми выборками:
В 1.1 соединила имя и фамилию, чтобы вывести полное ФИО сотрудников.
В 1.2 использовала DISTINCT для уникальных департаментов.
В 1.3 применила CASE, чтобы разделить бюджеты проектов на Large, Medium и Small.
В 1.4 через COALESCE заменила NULL в email на текст “No email provided”.
Вывод: простые запросы помогают аккуратно оформлять данные и делать вывод понятнее.


Part 2 — WHERE Clause and Comparison Operators
Здесь я фильтровала данные по условиям:
2.1 — выбрала сотрудников, нанятых после 2020 года.
2.2 — использовала BETWEEN для зарплаты от 60 000 до 70 000.
2.3 — LIKE для поиска фамилий, начинающихся на S или J.
2.4 — проверила, кто из IT имеет менеджера (manager_id IS NOT NULL).
 Вывод: через WHERE можно точечно отбирать нужные записи из таблицы.


Part 3 — String and Mathematical Functions
Тут я пробовала строковые и арифметические функции:
3.1 — UPPER, LENGTH, SUBSTRING для работы со строками.
3.2 — посчитала месячную зарплату и 10 % прибавку.
3.3 — через FORMAT() сделала красивую строку о проекте.
3.4 — с помощью AGE() и EXTRACT() посчитала, сколько лет человек работает в компании.
Вывод: такие функции удобны для аналитических отчётов и форматирования данных.


art 4 — Aggregate Functions and GROUP BY
4.1 — нашла среднюю зарплату по департаментам.
4.2 — через JOIN и SUM() посчитала часы по проектам.
4.3 — применила HAVING, чтобы показать только отделы с более чем одним сотрудником.
4.4 — нашла максимум, минимум и сумму всех зарплат.
 Вывод: GROUP BY и агрегаты (AVG, SUM, MAX, MIN) помогают делать сводные отчёты.


Part 5 — Set Operations
5.1 — использовала UNION, чтобы объединить две выборки (зарплата > 65 000 или дата найма > 2020).
5.2 — через INTERSECT нашла сотрудников из IT с высокой зарплатой.
5.3 — через EXCEPT показала, кто не назначен на проекты.
Вывод: операции над множествами удобны для сравнения разных условий.


art 6 — Subqueries
6.1 — EXISTS для проверки наличия назначений.
6.2 — IN с подзапросом для активных проектов.
6.3 — ANY для сравнения зарплаты с отделом Sales.
Вывод: подзапросы позволяют строить многоуровневую логику в одном SELECT.


Part 7 — Complex Queries
7.1 — посчитала средние часы по назначениям и ранжировала зарплаты по отделам (RANK() OVER).
7.2 — нашла проекты, где общее время > 150 ч.
7.3 — создала отчёт по отделам: количество сотрудников, средняя з/п и самый высокооплачиваемый сотрудник.
 Вывод: всё это помогает строить реальные аналитические отчёты в SQL.


Final Conclusion
В этой лабораторной я научилась использовать разные возможности SQL:
от простых фильтров до сложных подзапросов и оконных функций.
Теперь я могу писать понятные и эффективные запросы для анализа данных в реальных проектах.